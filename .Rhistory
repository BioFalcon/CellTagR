system.time(test_run <- jaccard_test_pairwise(filtered.whitelised.data.no.na))
my_pair <- combn(1:nrow(filtered.whitelised.data.no.na), 2, simplify = FALSE)
1+2585
2586*2585
subset.size <- c(100,150,200,250,300,350,400,450,500)
time.rslt <- list()
count.c <- 1
for (s.size in subset.size) {
print(s.size)
random.sample <- sample(rownames(filtered.whitelised.data.no.na), s.size)
time.rslt[[count.c]] <- system.time(test_run <- jaccard_test_pairwise(filtered.whitelised.data.no.na[random.sample,]))
count.c <- count.c + 1
}
time.rslt
time.rslt[[1]][1]
time.rslt[[1]][2]
time.rslt[[1]][3]
user.time.all <- unlist(lapply(time.rslt, function(x) x[1]))
elapsed.time.all <- unlist(lapply(time.rslt, function(x) x[3]))
plot(x = subset.size, y = user.time.all)
plot(x = subset.size, y = elapsed.time.all)
system.time.all <- unlist(lapply(time.rslt, function(x) x[2]))
user.time.all <- unlist(lapply(time.rslt, function(x) x[1]))
elapsed.time.all <- unlist(lapply(time.rslt, function(x) x[3]))
system.time.all <- unlist(lapply(time.rslt, function(x) x[2]))
plot(x = subset.size, y = user.time.all)
plot(x = subset.size, y = elapsed.time.all)
plot(x = subset.size, y = system.time.all)
system.time()
system.time.all
time.rslt[[1]]$system
time.rslt[[1]]
time.rslt[[6]]
time.rslt[[6]][2]
time.rslt[[6]][1]
time.rslt[[6]][3]
time.rslt[[6]]$
)
summary(time.rslt)
time.rslt[[6]][4]
time.rslt[[6]][5]
time.rslt[[6]][1]
user.time.all <- unlist(lapply(time.rslt, function(x) (x[1]+x[4)]))
user.time.all <- unlist(lapply(time.rslt, function(x) (x[1]+x[4])))
elapsed.time.all <- unlist(lapply(time.rslt, function(x) x[3]))
system.time.all <- unlist(lapply(time.rslt, function(x) (x[2]+x[5])))
plot(x = subset.size, y = user.time.all)
plot(x = subset.size, y = elapsed.time.all)
plot(x = subset.size, y = system.time.all)
test_run
which(random.sample[1,]>0)
random.sample[1,]
curr.mtx <- filtered.whitelised.data.no.na[random.sample,]
which(curr.mtx[1,]>0)
which(curr.mtx[2,]>0)
which(curr.mtx[3,]>0)
out
# create function to pass into mclapply
# jaccard.test supports multiple types of p value generations
# jaccard.test.bootstrap/jaccard.test.mca seem to be the most stable and appropriate (not an expert though)
my_test <- function(pair, data){
list(jaccard.test.mca(data[pair[1],],data[pair[2],]),
length(which(data[pair[2],] > 0)),
length(which(data[pair[1],] > 0)))
}
s.size <- 100
random.sample <- sample(rownames(filtered.whitelised.data.no.na), s.size)
dat <- filtered.whitelised.data.no.na[random.sample,]
# returns all unique permutations, will result in calculating upper triangle only
my_pair <- combn(1:nrow(dat), 2, simplify = FALSE)
# create function to pass into mclapply
# jaccard.test supports multiple types of p value generations
# jaccard.test.bootstrap/jaccard.test.mca seem to be the most stable and appropriate (not an expert though)
my_test <- function(pair, data){
list(jaccard.test.mca(data[pair[1],],data[pair[2],]),
length(which(data[pair[2],] > 0)),
length(which(data[pair[1],] > 0)))
}
# for all pairs, run jaccard.test.mca
out <- mclapply(my_pair, my_test, data = dat)
out
sapply(my_pair, '[[', 2),
sapply(my_pair, '[[', 2)
sapply(my_pair, '[[', 1)
sapply(out, '[[', "statistics")
out[[1]]
unlist(lapply(out, function(x) x[[1]]$statistics)
)
unlist(lapply(out, function(x) x[[1]]$pvalue))
out[[1]]
unlist(lapply(out, function(x) x[[2]]))
my_test <- function(pair, data){
list(jaccard.test.mca(data[pair[1],],data[pair[2],]),
length(which(data[pair[2],] > 0)),
length(which(data[pair[1],] > 0)))
}
# function to run jaccard test between all rows in a celltag@metric.filtered.count
jaccard_test_pairwise <- function(dat){
# returns all unique permutations, will result in calculating upper triangle only
my_pair <- combn(1:nrow(dat), 2, simplify = FALSE)
# for all pairs, run jaccard.test.mca
out <- mclapply(my_pair, my_test, data = dat)
# create long format table with statistics (jaccard coef) and p value (pvalue)
table <- data.frame(i = sapply(my_pair, '[[', 2),
j = sapply(my_pair, '[[', 1),
i.ct = unlist(lapply(out, function(x) x[[2]])),
j.ct = unlist(lapply(out, function(x) x[[3]])),
statistic = unlist(lapply(out, function(x) x[[1]]$statistics)),
p.value = unlist(lapply(out, function(x) x[[1]]$pvalue)))
return(table)
}
subset.size <- c(50, 75, 100, 125, 150, 175, 200, 250, 300, 350, 400, 450, 500)
time.rslt <- list()
count.c <- 1
rslt.list <- list()
for (s.size in subset.size) {
print(s.size)
random.sample <- sample(rownames(filtered.whitelised.data.no.na), s.size)
time.rslt[[count.c]] <- system.time(rslt.list[[count.c]] <- jaccard_test_pairwise(filtered.whitelised.data.no.na[random.sample,]))
count.c <- count.c + 1
}
user.time.all <- unlist(lapply(time.rslt, function(x) (x[1]+x[4])))
elapsed.time.all <- unlist(lapply(time.rslt, function(x) x[3]))
system.time.all <- unlist(lapply(time.rslt, function(x) (x[2]+x[5])))
plot(x = subset.size, y = user.time.all)
plot(x = subset.size, y = elapsed.time.all)
plot(x = subset.size, y = system.time.all)
jaccard.test.mca
# create function to pass into mclapply
# jaccard.test supports multiple types of p value generations
# jaccard.test.bootstrap/jaccard.test.mca seem to be the most stable and appropriate (not an expert though)
my_test <- function(pair, data){
list(jaccard.test.mca(data[pair[1],],data[pair[2],]),
length(which(data[pair[2],] > 0)),
length(which(data[pair[1],] > 0)),
length(intersect(names(which(data[pair[2],] > 0)), names(which(data[pair[1],] > 0)))))
}
# function to run jaccard test between all rows in a celltag@metric.filtered.count
jaccard_test_pairwise <- function(dat){
# returns all unique permutations, will result in calculating upper triangle only
my_pair <- combn(1:nrow(dat), 2, simplify = FALSE)
# for all pairs, run jaccard.test.mca
out <- mclapply(my_pair, my_test, data = dat)
# create long format table with statistics (jaccard coef) and p value (pvalue)
table <- data.frame(i = sapply(my_pair, '[[', 2),
j = sapply(my_pair, '[[', 1),
i.ct = unlist(lapply(out, function(x) x[[2]])),
j.ct = unlist(lapply(out, function(x) x[[3]])),
int.ct = unlist(lapply(out, function(x) x[[4]])),
statistic = unlist(lapply(out, function(x) x[[1]]$statistics)),
p.value = unlist(lapply(out, function(x) x[[1]]$pvalue)))
return(table)
}
subset.size <- c(50, 75, 100, 125, 150, 175, 200, 250, 300, 350, 400, 450, 500)
time.rslt <- list()
count.c <- 1
rslt.list <- list()
for (s.size in subset.size) {
print(s.size)
random.sample <- sample(rownames(filtered.whitelised.data.no.na), s.size)
time.rslt[[count.c]] <- system.time(rslt.list[[count.c]] <- jaccard_test_pairwise(filtered.whitelised.data.no.na[random.sample,]))
count.c <- count.c + 1
}
user.time.all <- unlist(lapply(time.rslt, function(x) (x[1]+x[4])))
elapsed.time.all <- unlist(lapply(time.rslt, function(x) x[3]))
system.time.all <- unlist(lapply(time.rslt, function(x) (x[2]+x[5])))
plot(x = subset.size, y = user.time.all)
plot(x = subset.size, y = elapsed.time.all)
plot(x = subset.size, y = system.time.all)
intersection.ct.count <- lapply(rslt.list, function(x) x[,c("int.ct", "p.value")])
View(intersection.ct.count)
intersection.ct.count.df <- rbindlist(intersection.ct.count)
View(intersection.ct.count.df)
plot(intersection.ct.count.df$int.ct, intersection.ct.count.df$p.value)
intersection.ct.count.df$overlap <- paste0("Overlap_CellTag_", intersection.ct.count.df$int.ct)
View(intersection.ct.count.df)
ggplot(intersection.ct.count.df, aes(x=p.value, color = overlap)) +
geom_density() +
scale_color_discrete()
ggplot(intersection.ct.count.df, aes(x=p.value, color = overlap)) +
geom_density() +
scale_color_discrete()
ggplot(intersection.ct.count.df, aes(x = overlap, y = p.value, color = overlap)) +
geom_point() +
scale_color_viridis_d()
ggplot(intersection.ct.count.df, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter() +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90))
intersection.ct.count.df$overlap <- paste0("Overlap_CellTag_", intersection.ct.count.df$int.ct)
ggplot(intersection.ct.count.df, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
intersection.ct.count.df.sub <- intersection.ct.count.df[which(intersection.ct.count.df$int.ct >= 1), ]
plot(intersection.ct.count.df.sub$int.ct, intersection.ct.count.df.sub$p.value)
ggplot(intersection.ct.count.df.sub, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
intersection.ct.count.df$overlap <- paste0("Overlap_CellTag_", intersection.ct.count.df$int.ct)
intersection.ct.count.df$overlap <- factor(intersection.ct.count.df$overlap, levels = c("Overlap_CellTag_0", "Overlap_CellTag_1", "Overlap_CellTag_2","Overlap_CellTag_3", "Overlap_CellTag_4", "Overlap_CellTag_5", "Overlap_CellTag_6", "Overlap_CellTag_7", "Overlap_CellTag_8", "Overlap_CellTag_9", "Overlap_CellTag_10", "Overlap_CellTag_11", "Overlap_CellTag_18"), ordered = T)
ggplot(intersection.ct.count.df, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
intersection.ct.count.df.sub <- intersection.ct.count.df[which(intersection.ct.count.df$int.ct >= 1), ]
ggplot(intersection.ct.count.df.sub, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df.sub, aes(x = overlap, y = -log10(p.value), color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df, aes(x = overlap, y = -log10(p.value), color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df, aes(x = overlap, y = -log10(p.value), fill = overlap)) +
geom_violin() +
scale_fill_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df, aes(x = overlap, y = -log10(p.value), fill = overlap)) +
geom_boxplot() +
scale_fill_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
subset.size <- c(50, 75, 100, 125, 150, 175, 200, 250, 300, 350, 400, 450, 500)
time.rslt <- list()
time.rslt.2 <- list()
count.c <- 1
rslt.list <- list()
rslt.list.2 <- list()
for (s.size in subset.size) {
print(s.size)
random.sample <- sample(rownames(filtered.whitelised.data.no.na), s.size)
time.rslt[[count.c]] <- system.time(rslt.list[[count.c]] <- jaccard_test_pairwise(filtered.whitelised.data.no.na[random.sample,]))
time.rslt.2[[count.c]] <- system.time(rslt.list.2[[count.c]] <- simil(as.matrix(filtered.whitelised.data.no.na[random.sample,]), method = "Jaccard"))
count.c <- count.c + 1
}
user.time.all <- unlist(lapply(time.rslt, function(x) (x[1]+x[4])))
elapsed.time.all <- unlist(lapply(time.rslt, function(x) x[3]))
system.time.all <- unlist(lapply(time.rslt, function(x) (x[2]+x[5])))
plot(x = subset.size, y = user.time.all)
plot(x = subset.size, y = elapsed.time.all)
plot(x = subset.size, y = system.time.all)
user.time.all.2 <- unlist(lapply(time.rslt.2, function(x) (x[1]+x[4])))
elapsed.time.all.2 <- unlist(lapply(time.rslt.2, function(x) x[3]))
system.time.all.2 <- unlist(lapply(time.rslt.2, function(x) (x[2]+x[5])))
plot(x = subset.size, y = user.time.all.2)
plot(x = subset.size, y = elapsed.time.all.2)
plot(x = subset.size, y = system.time.all.2)
plot(x = subset.size, y = elapsed.time.all.2)
points(x = subset.size, y = elapsed.time.all, col = "red")
plot(x = subset.size, y = elapsed.time.all.2) + ylim(0,150)
points(x = subset.size, y = elapsed.time.all, col = "red")
plot(x = subset.size, y = elapsed.time.all.2) + ylim(0,150)
points(x = subset.size, y = elapsed.time.all, col = "red")
?points
plot(x = subset.size, y = elapsed.time.all)
points(x = subset.size, y = elapsed.time.all.2, col = "red")
intersection.ct.count <- lapply(rslt.list, function(x) x[,c("int.ct", "p.value")])
intersection.ct.count.df <- rbindlist(intersection.ct.count)
plot(intersection.ct.count.df$int.ct, intersection.ct.count.df$p.value)
intersection.ct.count.df$overlap <- paste0("Overlap_CellTag_", intersection.ct.count.df$int.ct)
intersection.ct.count.df$overlap <- factor(intersection.ct.count.df$overlap, levels = c("Overlap_CellTag_0", "Overlap_CellTag_1", "Overlap_CellTag_2","Overlap_CellTag_3", "Overlap_CellTag_4", "Overlap_CellTag_5", "Overlap_CellTag_6", "Overlap_CellTag_7", "Overlap_CellTag_8", "Overlap_CellTag_9", "Overlap_CellTag_10", "Overlap_CellTag_11", "Overlap_CellTag_18"), ordered = T)
ggplot(intersection.ct.count.df, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df, aes(x = overlap, y = -log10(p.value), color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df, aes(x = overlap, y = -log10(p.value), fill = overlap)) +
geom_boxplot() +
scale_fill_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
intersection.ct.count.df.sub <- intersection.ct.count.df[which(intersection.ct.count.df$int.ct >= 1), ]
ggplot(intersection.ct.count.df.sub, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df.sub, aes(x = overlap, y = -log10(p.value), color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
unique(intersection.ct.count.df$overlap)
intersection.ct.count.df$overlap <- paste0("Overlap_CellTag_", intersection.ct.count.df$int.ct)
unique(intersection.ct.count.df$overlap)
intersection.ct.count.df$overlap <- paste0("Overlap_CellTag_", intersection.ct.count.df$int.ct)
intersection.ct.count.df$overlap <- factor(intersection.ct.count.df$overlap, levels = c("Overlap_CellTag_0", "Overlap_CellTag_1", "Overlap_CellTag_2","Overlap_CellTag_3", "Overlap_CellTag_4", "Overlap_CellTag_5", "Overlap_CellTag_6", "Overlap_CellTag_7", "Overlap_CellTag_8", "Overlap_CellTag_9", "Overlap_CellTag_10", "Overlap_CellTag_11", "Overlap_CellTag_14", "Overlap_CellTag_15", "Overlap_CellTag_17", "Overlap_CellTag_18"), ordered = T)
ggplot(intersection.ct.count.df, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df, aes(x = overlap, y = -log10(p.value), color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df, aes(x = overlap, y = -log10(p.value), fill = overlap)) +
geom_boxplot() +
scale_fill_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
intersection.ct.count.df.sub <- intersection.ct.count.df[which(intersection.ct.count.df$int.ct >= 1), ]
ggplot(intersection.ct.count.df.sub, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df.sub, aes(x = overlap, y = -log10(p.value), color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
?mapply
new.list.rslt.simil <- mapply(rslt.list, rslt.list.2, function(x,y) data.frame(i = x$i, j = x$j, jac = y[x$i, x$j]))
new.list.rslt.simil <- mapply(function(x,y) data.frame(i = x$i, j = x$j, jac = y[x$i, x$j]), rslt.list, rslt.list.2)
new.list.rslt.simil <- mapply(function(x,y) data.frame(i = x$i, j = x$j, jac = as.matrix(y)[x$i, x$j]), rslt.list, rslt.list.2)
rslt.list.2.mtx <- lapply(rslt.list.2, function(x) as.matri(x))
rslt.list.2.mtx <- lapply(rslt.list.2, function(x) as.matrix(x))
unique(rslt.list[[1]]$i)
new.list.rslt.simil <- mapply(function(x,y) data.frame(i = x$i, j = x$j, jac = as.matrix(y)[x$i, x$j]), rslt.list, rslt.list.2)
rslt.list.2.mtx <- lapply(rslt.list.2, function(x) as.matrix(x))
new.list.rslt.simil <- mapply(function(x,y) data.frame(i = x$i, j = x$j, jac = y[x$i, x$j]), rslt.list, rslt.list.2.mtx)
?simil
library(jaccard)
library(parallel)
# create function to pass into mclapply
# jaccard.test supports multiple types of p value generations
# jaccard.test.bootstrap/jaccard.test.mca seem to be the most stable and appropriate (not an expert though)
my_test <- function(pair, data){
list(jaccard.test.mca(data[pair[1],],data[pair[2],]),
length(which(data[pair[2],] > 0)),
length(which(data[pair[1],] > 0)),
length(intersect(names(which(data[pair[2],] > 0)), names(which(data[pair[1],] > 0)))),
simil(x = data[pair[1],], y = data[pair[2],], method = "Jaccard"))
}
# function to run jaccard test between all rows in a celltag@metric.filtered.count
jaccard_test_pairwise <- function(dat){
# returns all unique permutations, will result in calculating upper triangle only
my_pair <- combn(1:nrow(dat), 2, simplify = FALSE)
# for all pairs, run jaccard.test.mca
out <- mclapply(my_pair, my_test, data = dat)
# create long format table with statistics (jaccard coef) and p value (pvalue)
table <- data.frame(i = sapply(my_pair, '[[', 2),
j = sapply(my_pair, '[[', 1),
i.ct = unlist(lapply(out, function(x) x[[2]])),
j.ct = unlist(lapply(out, function(x) x[[3]])),
int.ct = unlist(lapply(out, function(x) x[[4]])),
statistic = unlist(lapply(out, function(x) x[[1]]$statistics)),
p.value = unlist(lapply(out, function(x) x[[1]]$pvalue)),
siml.jaccard = unlist(lapply(out, function(x) x[[5]])))
return(table)
}
subset.size <- c(50, 75, 100, 125, 150, 175, 200, 250, 300, 350, 400, 450, 500)
time.rslt <- list()
time.rslt.2 <- list()
count.c <- 1
rslt.list <- list()
rslt.list.2 <- list()
for (s.size in subset.size) {
print(s.size)
random.sample <- sample(rownames(filtered.whitelised.data.no.na), s.size)
time.rslt[[count.c]] <- system.time(rslt.list[[count.c]] <- jaccard_test_pairwise(filtered.whitelised.data.no.na[random.sample,]))
time.rslt.2[[count.c]] <- system.time(rslt.list.2[[count.c]] <- simil(as.matrix(filtered.whitelised.data.no.na[random.sample,]), method = "Jaccard"))
count.c <- count.c + 1
}
library(jaccard)
library(parallel)
# create function to pass into mclapply
# jaccard.test supports multiple types of p value generations
# jaccard.test.bootstrap/jaccard.test.mca seem to be the most stable and appropriate (not an expert though)
my_test <- function(pair, data){
list(jaccard.test.mca(data[pair[1],],data[pair[2],]),
length(which(data[pair[2],] > 0)),
length(which(data[pair[1],] > 0)),
length(intersect(names(which(data[pair[2],] > 0)), names(which(data[pair[1],] > 0)))))
}
# function to run jaccard test between all rows in a celltag@metric.filtered.count
jaccard_test_pairwise <- function(dat){
# returns all unique permutations, will result in calculating upper triangle only
my_pair <- combn(1:nrow(dat), 2, simplify = FALSE)
# for all pairs, run jaccard.test.mca
out <- mclapply(my_pair, my_test, data = dat)
# create long format table with statistics (jaccard coef) and p value (pvalue)
table <- data.frame(i = sapply(my_pair, '[[', 2),
j = sapply(my_pair, '[[', 1),
i.ct = unlist(lapply(out, function(x) x[[2]])),
j.ct = unlist(lapply(out, function(x) x[[3]])),
int.ct = unlist(lapply(out, function(x) x[[4]])),
statistic = unlist(lapply(out, function(x) x[[1]]$statistics)),
p.value = unlist(lapply(out, function(x) x[[1]]$pvalue)))
return(table)
}
subset.size <- c(50, 75, 100, 125, 150, 175, 200, 250, 300, 350, 400, 450, 500)
time.rslt <- list()
time.rslt.2 <- list()
count.c <- 1
rslt.list <- list()
rslt.list.2 <- list()
for (s.size in subset.size) {
print(s.size)
random.sample <- sample(rownames(filtered.whitelised.data.no.na), s.size)
time.rslt[[count.c]] <- system.time(rslt.list[[count.c]] <- jaccard_test_pairwise(filtered.whitelised.data.no.na[random.sample,]))
time.rslt.2[[count.c]] <- system.time(rslt.list.2[[count.c]] <- simil(as.matrix(filtered.whitelised.data.no.na[random.sample,]), method = "Jaccard"))
count.c <- count.c + 1
}
user.time.all <- unlist(lapply(time.rslt, function(x) (x[1]+x[4])))
elapsed.time.all <- unlist(lapply(time.rslt, function(x) x[3]))
system.time.all <- unlist(lapply(time.rslt, function(x) (x[2]+x[5])))
plot(x = subset.size, y = user.time.all)
plot(x = subset.size, y = elapsed.time.all)
plot(x = subset.size, y = system.time.all)
user.time.all.2 <- unlist(lapply(time.rslt.2, function(x) (x[1]+x[4])))
elapsed.time.all.2 <- unlist(lapply(time.rslt.2, function(x) x[3]))
system.time.all.2 <- unlist(lapply(time.rslt.2, function(x) (x[2]+x[5])))
plot(x = subset.size, y = user.time.all.2)
plot(x = subset.size, y = elapsed.time.all.2)
plot(x = subset.size, y = system.time.all.2)
plot(x = subset.size, y = elapsed.time.all)
points(x = subset.size, y = elapsed.time.all.2, col = "red")
intersection.ct.count <- lapply(rslt.list, function(x) x[,c("int.ct", "p.value")])
intersection.ct.count.df <- rbindlist(intersection.ct.count)
plot(intersection.ct.count.df$int.ct, intersection.ct.count.df$p.value)
intersection.ct.count.df$overlap <- paste0("Overlap_CellTag_", intersection.ct.count.df$int.ct)
unique(intersection.ct.count.df$overlap)
intersection.ct.count.df$overlap <- paste0("Overlap_CellTag_", intersection.ct.count.df$int.ct)
intersection.ct.count.df$overlap <- factor(intersection.ct.count.df$overlap, levels = c("Overlap_CellTag_0", "Overlap_CellTag_1", "Overlap_CellTag_2","Overlap_CellTag_3", "Overlap_CellTag_4", "Overlap_CellTag_5", "Overlap_CellTag_6", "Overlap_CellTag_7", "Overlap_CellTag_8", "Overlap_CellTag_9", "Overlap_CellTag_10", "Overlap_CellTag_11", "Overlap_CellTag_15", "Overlap_CellTag_18"), ordered = T)
ggplot(intersection.ct.count.df, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df, aes(x = overlap, y = -log10(p.value), color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df, aes(x = overlap, y = -log10(p.value), fill = overlap)) +
geom_boxplot() +
scale_fill_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
intersection.ct.count.df.sub <- intersection.ct.count.df[which(intersection.ct.count.df$int.ct >= 1), ]
ggplot(intersection.ct.count.df.sub, aes(x = overlap, y = p.value, color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
ggplot(intersection.ct.count.df.sub, aes(x = overlap, y = -log10(p.value), color = overlap)) +
geom_jitter(size = 0.5) +
scale_color_viridis_d() +
theme(axis.text.x = element_text(angle = 90),
legend.position = "none")
rslt.list.2.mtx <- lapply(rslt.list.2, function(x) as.matrix(x))
i <- 1
curr.df <- rslt.list[[i]]
siml.mtx.curr <- rslt.list.2.mtx[[i]]
curr.df
new.df <- data.frame(i = curr.df$i, j = curr.df$j, jac = siml.mtx.curr[curr.df$i, curr.df$j])
View(new.df)
siml.mtx.curr
siml.mtx.curr[curr.df$i, curr.df$j]
rslt.list.2.mtx <- lapply(rslt.list.2, function(x) as.matrix(x))
new.list.simil <- list()
for (k in 1:length(rslt.list)){
print(k)
curr.df <- rslt.list[[k]]
siml.mtx.curr <- rslt.list.2.mtx[[k]]
new.df.set <- data.frame()
for (x in 1:nrow(curr.df)) {
curr.curr.df <- data.frame(i = curr.df$i[x], j = curr.df$j[x], jac = siml.mtx.curr[curr.df$i[x], curr.df$j[x]])
if (nrow(new.df.set) <= 0){
new.df.set <- curr.curr.df
} else {
new.df.set <- rbind(new.df.set, curr.curr.df)
}
}
new.list.simil[[k]] <- new.df.set
}
jaccard.simil.df <- rbindlist(new.list.simil)
jaccard.test.ev.df <- rbindlist(rslt.list)
plot(x=jaccard.simil.df$jac, y = jaccard.test.ev.df$statistic)
View(jaccard.simil.df)
View(jaccard.test.ev.df)
cor(jaccard.simil.df$jac, jaccard.test.ev.df$statistic)
celltag.obj <- JaccardAnalysis(celltag.obj)
# Call clones
celltag.obj <- CloneCalling(celltag.obj = celltag.obj, correlation.cutoff=0.7)
gc()
library(roxygen2)
library(devtools)
setwd("~/De")
setwd("~/Desktop/CellTagR/")
document()
